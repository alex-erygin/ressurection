open System

// ★★★★★★★★★★★★★★★★★
// Partial Active Patterns
// ★★★★★★★★★★★★★★★★★
let parse (input: string) =
    match DateTime.TryParse(input) with
    | true, value -> Some value
    | false, _ -> None

let isDate = parse "2023-10-22"
let isNotDate = parse "Hello"

let (|ValidDate|_|) (input: string) =
    match DateTime.TryParse(input) with
    | true, value -> Some value
    | false, _ -> None

let parse2 input =
    match input with
    | ValidDate dt -> printfn $"%A{dt}"
    | _ -> printfn $"'%s{input}' is not a valid date"
    
parse2 "2023-12-30"
parse2 "Hello"

// ★★★★★★★★★★★★★★★★★
// Parameterized Partial Active Patterns
// ★★★★★★★★★★★★★★★★★


// Parameterized partial active patterns differ from basic partial active patterns by supplying additional
// input items.
// We are going to investigate how an old interview favourite, FizzBuzz, can be implemented using a
// parameterized partial active pattern. Let’s start with the canonical solution

let calculate i =
    if i % 3 = 0 && i % 5 = 0 then "FizzBuzz"
    elif i% 3 = 0 then "Fizz"
    elif i % 5 = 0 then "Buzz"
    else i |> string
    
[1..15] |> List.map calculate

let (|IsDivisibleBy|_|) divisors n =
    if divisors |> List.forall (fun div -> n % div = 0)
    then Some ()
    else None

//The List.reduce function will concatenate all of the strings generated by the List.map function.
// The last line is to cater for numbers that are not divisible by any of the numbers in the initial list.
let calculate2 n =
    [(3, "Fizz");(5, "Buzz")]
    |> List.map (fun (divisor, result) -> if n % divisor = 0 then result else "")
    |> List.reduce (+)
    |> fun input -> if input = "" then string n else input
    
[1..15] |> List.map calculate2

// ★★★★★★★★★★★★★★★★★
// Multi-Case Active Patterns
// ★★★★★★★★★★★★★★★★★


// Multi-Case Active Patterns are different from Partial Active Patterns in that they always return one
// of the possible values rather than an option type. The maximum number of choices supported is
// currently seven although that may increase in a future version of F#.
type Rank = Ace|Two|Three|Four|Five|Six|Seven|Eight|Nine|Ten|Jack|Queen|King
type Suit = Hearts|Clubs|Diamonds|Spades
type Card = Rank * Suit

let (|Red|Black|) (card:Card) =
    match card with
    | (_, Diamonds) | (_, Hearts) -> Red
    | (_, Clubs) | (_, Spades) -> Black
    
    
let describeColour card =
    match card with
    | Red -> "red"
    | Black -> "black"
    |> printfn "The card is %s"

describeColour (Two, Hearts)

// ★★★★★★★★★★★★★★★★★
//Single-Case Active Patterns
// ★★★★★★★★★★★★★★★★★


// The last type of active pattern that we will look at is the single-case. The purpose of the single-case
// is to allow you to decompose an input in different ways

let (|CharacterCount|) (input:string) =
    input.Length
    
let (|ContainsANumber|) (input:string) =
    input
    |> Seq.filter Char.IsDigit
    |> Seq.length > 0

let (|IsValidPassword|) input =
    match input with
    | CharacterCount len when len < 8 -> (false, "Password must be at least 8 characters")
    | ContainsANumber false -> (false, "Password must contain at least 1 digit.")
    | _ -> (true, "")
    
let setPassword input =
    match input with
    | IsValidPassword (true, _) as pwd -> Ok pwd
    | IsValidPassword (false, failureReason) -> Error $"Password not set: %s{failureReason}"

let badPassword = setPassword "password"
let goodPassword = setPassword "passw0rd"
